#!/usr/bin/env python

import sys
import csv
import itertools
import operator


def pretty(rows):
    cols = [
        'dataset',
        'resource',
        'base',
        'model',
        'property',
        'source',
        'prepare',
        'type',
        'ref',
        'level',
        'access',
        'title',
        'description',
    ]

    hpos = cols.index('property')
    hsize = 1  # hierachical column size
    bsize = 3  # border size
    sizes = dict(
        [(c, 1) for c in cols[:hpos]] +
        [(c, len(c)) for c in cols[hpos:]]
    )
    rows = list(rows)
    for row in rows:
        for i, col in enumerate(cols):
            val = str(row[col])
            if i < hpos:
                size = (hsize + bsize) * (hpos - i) + sizes['property']
                if size < len(val):
                    sizes['property'] += len(val) - size
            elif sizes[col] < len(val):
                sizes[col] = len(val)

    line = []
    for col in cols:
        size = sizes[col]
        line.append(col[:size].ljust(size))

    depth = 0
    lines = [line]
    for row in rows:
        line = []

        for i, col in enumerate(cols[:hpos + 1]):
            val = row[col]
            if val:
                depth = i
                break
        else:
            val = ''
            if depth < hpos:
                depth += 1
            else:
                depth = 2

        line += [' ' * hsize] * depth
        size = (hsize + bsize) * (hpos - depth) + sizes['property']
        line += [val.ljust(size)]

        for col in cols[hpos + 1:]:
            val = str(row[col])
            size = sizes[col]
            line.append(val.ljust(size))

        lines.append(line)

    lines = [' | '.join(line) for line in lines]
    indent = '    '
    return '\n'.join([indent + l.rstrip() for l in lines]) + '\n' + indent


def fix_empty(rows):
    a = next(rows)
    yield a
    for b in rows:
        if all(b[c] == '' for c in ('dataset', 'resource', 'origin', 'model', 'property', 'object', 'column')):
            continue
        if b['dataset'] == '':
            b['dataset'] = a['dataset']
        yield b
        a = b


def convert():
    with open(sys.argv[1]) as f:
        next(f)
        next(f)
        reader = csv.DictReader(f, [
            'open',
            'dataset',
            'resource',
            'origin',
            'model',
            'property',
            'type',
            'ref',
            'const',
            'title',
            'description',
            'object',
            'column',
            'ref.table',
            'ref.column',
        ])

        default = {
            'dataset': '',
            'resource': '',
            'base': '',
            'model': '',
            'property': '',
            'source': '',
            'prepare': '',
            'type': '',
            'ref': '',
            'level': '',
            'access': '',
            'title': '',
            'description': '',
        }

        # reader = (x for _, x in zip(range(200), reader))
        reader = fix_empty(reader)
        reader = itertools.groupby(reader, key=operator.itemgetter('dataset'))
        for dataset, resources in reader:
            yield {**default, 'dataset': dataset}
            resources = itertools.groupby(resources, key=operator.itemgetter('resource'))
            for resource, objects in resources:
                yield {**default, 'resource': resource}
                objects = itertools.groupby(objects, key=operator.itemgetter('origin'))
                for origin, models in objects:
                    models = itertools.groupby(models, key=operator.itemgetter('model'))
                    for model, props in models:
                        yield {**default, 'base': ''}

                        props = list(props)

                        if props[0]['property'] == '':
                            row = props[0]
                            props = props[1:]
                        else:
                            row = {
                                **default,
                                'object': props[0]['object'],
                                'column': props[0]['column'],
                            }

                        pkeys = []
                        for prop in props:
                            if prop['type'] == 'pk':
                                prop['type'] = 'integer'
                                pkeys.append(prop['property'])

                        if row['column'] == '':
                            prepare = row['object']
                            for prop in props:
                                if prop['column']:
                                    source = prop['object']
                                    break
                        else:
                            prepare = ''
                            source = row['object']

                        yield {
                            **default,
                            'model': source.replace('$', '/').lower(),
                            'source': source,
                            'prepare': prepare,
                            'ref': ', '.join(pkeys),
                            'title': row['title'],
                            'description': row['description'],
                        }

                        for row in props:
                            if row['property'] in pkeys or row['type'] == 'ref':
                                level = 4
                            else:
                                level = 3

                            if row['column'] == '':
                                prepare = row['object']
                            else:
                                prepare = ''

                            yield {
                                **default,
                                'property': row['property'],
                                'source': row['column'],
                                'prepare': prepare,
                                'type': row['type'],
                                'ref': row['ref'].replace('raw/vpt/new/', ''),
                                'level': str(level),
                                'access': {
                                    '': '',
                                    'N': 'private',
                                    'A': 'public',
                                    'T': 'open',
                                }.get(row['open'], 'open'),
                                'title': row['title'],
                                'description': row['description'],
                            }


with open('/tmp/vpt.csv', 'w') as f:
    writer = csv.DictWriter(f, [
        'dataset',
        'resource',
        'base',
        'model',
        'property',
        'source',
        'prepare',
        'type',
        'ref',
        'level',
        'access',
        'title',
        'description',
    ])
    writer.writeheader()
    for row in convert():
        writer.writerow(row)

# print(pretty(list(convert())))
